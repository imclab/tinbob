package tinbob.display{
	import __AS3__.vec.Vector;		import com.greensock.TweenMax;	import com.greensock.easing.Sine;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.BitmapDataChannel;	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.InterpolationMethod;	import flash.display.Shape;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.filters.BitmapFilter;	import flash.filters.BitmapFilterQuality;	import flash.filters.BlurFilter;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.Timer;		import hype.extended.behavior.FixedVibration;	import hype.extended.behavior.SimpleProximity;	import hype.extended.color.ColorPool;	import hype.extended.layout.GridLayout;	import hype.framework.core.ObjectPool;		import org.osflash.signals.Signal;		import tinbob.data.NavigationInfo;	import tinbob.data.PageInfo;	import tinbob.data.PostBackgroundInfo;	import tinbob.data.PostInfo;		import uk.co.soulwire.display.colour.ColourUtils;
	public class Background extends Sprite	{			public var rollOver:Signal;				public var nullNavitationInfo:NavigationInfo;		public var nullPostBackground:PostBackgroundInfo;				private var _postBackgrounds:Vector.<PostBackgroundInfo>;		private var _pageBackgrounds:Vector.<PostBackgroundInfo>;				private static const inactiveColor:uint = 0x444444;		private static const inactiveGradientColor:uint = 0x000000;		private static const clipRemovalDuration:Number = 0.6;		//private static const TILE_HEIGHT:int = 200;						private var _container:Sprite;		private var _base:Sprite;				private var _currentPost:int;		private var _isPost:Boolean;				private var w:Number;		private var h:Number;				private var _w:Number;		private var _h:Number;				private var _clipsW:Number;		private var _clipsH:Number;		private var _nClips:int;		private var _clipsCols:int;				private var pool:ObjectPool;						private var initialized:Boolean;				private var deselectTimer:Timer;				private var _isBlocked:Boolean;		private var _isDisabled:Boolean;				private var _disableColorize:Boolean;				private var _inTransition:Boolean;						/////////////////////////////////////////////////////////////////////////////////////		// Constructor ----------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						public function Background (width:int = 800, height:int = 600)		{			w = width;			h = height;											_nClips = 36;			_clipsCols = 6;						_clipsH = h*0.6;						rollOver = new Signal(NavigationInfo);						_postBackgrounds= new Vector.<PostBackgroundInfo>();			_pageBackgrounds= new Vector.<PostBackgroundInfo>();						_base = prepareBase(w,h);			addChild(_base);						_container = new Sprite();			addChild(_container);						_currentPost = -1;			_isPost = false;						initialized = false;						this.addEventListener(MouseEvent.ROLL_OVER, onRollOver, false, 0, true);						deselectTimer = new Timer(500,1);												nullNavitationInfo = new NavigationInfo();			nullNavitationInfo.label = -1;			nullNavitationInfo.hAlign = -1;			nullNavitationInfo.vAlign = -1;			nullNavitationInfo.col = -1;			nullNavitationInfo.row = -1;						nullPostBackground = new PostBackgroundInfo();			nullPostBackground.label = -1;			nullPostBackground.colors = [0x454545, 0x454545, 0x000000, 0x111111,0x000000, 0x111111,0x000000, 0x111111,0x000000, 0x111111];						_inTransition = false;			_disableColorize = false;					}		/////////////////////////////////////////////////////////////////////////////////////		// removeAllListeners ----------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function removeAllListeners():void		{			rollOver.removeAll();		}		/////////////////////////////////////////////////////////////////////////////////////		// setup ----------------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function setup():void		{			if(_inTransition) transitionOut(true);			this.visible = true;		}		/////////////////////////////////////////////////////////////////		// transitionOut --------------------------------------------------		/////////////////////////////////////////////////////////////////		public function transitionOut(imediate:Boolean = false):void {			_inTransition = true;			_inTransition = false;			this.visible = false;		}		/////////////////////////////////////////////////////////////////////////////////////		// disableColorize ------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function disableColorize(value:Boolean):void		{			_disableColorize = value;		}		/////////////////////////////////////////////////////////////////////////////////////		// disable --------------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function disable(value:Boolean):void		{			_isDisabled = value;			if (_isDisabled){				this.removeEventListener(MouseEvent.ROLL_OVER, onRollOver);				deselectTimer.reset();				deselectTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onDeselectTimerComplete);				removeClips();				pool = null;				if(contains(_base))removeChild(_base);				if(contains(_container))removeChild(_container);							}			else {				if(!contains(_base))addChild(_base);				if(!contains(_container))addChild(_container);				this.addEventListener(MouseEvent.ROLL_OVER, onRollOver, false, 0,true);				if(_isPost)	addClips(_postBackgrounds[_currentPost]);				else addClips(_pageBackgrounds[_currentPost]);			}		}		/////////////////////////////////////////////////////////////////////////////////////		// onPostsLoaded --------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onPostsLoaded(posts:Vector.<PostInfo>):void {			// check if posts were nt already loaded			if (_postBackgrounds.length == 0)			{				for each (var post:PostInfo in posts)				{					var postBackground:PostBackgroundInfo = new PostBackgroundInfo();					postBackground.label = post.label;					postBackground.colors = nullPostBackground.colors;					_postBackgrounds.push(postBackground);				}			}					}		/////////////////////////////////////////////////////////////////////////////////////		// onPagesLoaded --------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onPagesLoaded(pages:Vector.<PageInfo>):void {			// check if pages were nt already loaded			if (_pageBackgrounds.length == 0) 			{				for each (var page:PageInfo in pages)				{					var pageBackground:PostBackgroundInfo = new PostBackgroundInfo();					pageBackground.label = page.label;					pageBackground.colors = nullPostBackground.colors;					_pageBackgrounds.push(pageBackground);				}			}					}		/////////////////////////////////////////////////////////////////////////////////////		// onNavigationChanged --------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onNavigationChanged(navigationInfo:NavigationInfo):void		{			//for each (var thumbnail:PostThumbnail in _thumbnails)thumbnail.onNavigationChanged(navigationInfo);		}		/////////////////////////////////////////////////////////////////////////////////////		// onColorExtracted ----------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onColorExtracted(label:int, colors:Array):void		{			_postBackgrounds[label].colors = colors;						if(_isPost && _currentPost == label){				var tempDisableColorize:Boolean = _disableColorize;				_disableColorize = false;				open(_postBackgrounds[label]);					_disableColorize = tempDisableColorize;			} 				}		/////////////////////////////////////////////////////////////////////////////////////		// onPageColorExtracted ----------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onPageColorExtracted(label:int, colors:Array):void		{			_pageBackgrounds[label].colors = colors;						if(_isPost && _currentPost == label) {				var tempDisableColorize:Boolean = _disableColorize;				_disableColorize = false;				open(_pageBackgrounds[label]);				_disableColorize = tempDisableColorize;			}		}		/////////////////////////////////////////////////////////////////////////////////////		// onPostSelected -------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onPostSelected(navigationInfo:NavigationInfo):void {			deselectTimer.reset();			if(!_disableColorize){				if(navigationInfo.label == -1){					_currentPost = navigationInfo.label;					_isPost = false;					open(nullPostBackground, false);				}				else if (navigationInfo.isPost){					for each(var itemPost:PostBackgroundInfo in _postBackgrounds)					{						if(itemPost.label == navigationInfo.label){							_currentPost = itemPost.label;							_isPost = navigationInfo.isPost;							open(itemPost);						}					}				}				else if (!navigationInfo.isPost){					for each(var itemPage:PostBackgroundInfo in _pageBackgrounds)					{						if(itemPage.label == navigationInfo.label){							_currentPost = itemPage.label;							_isPost = navigationInfo.isPost;							open(itemPage);						}					}				}			}		}		/////////////////////////////////////////////////////////////////////////////////////		// onRollOver -----------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onRollOver(e:MouseEvent):void		{			if(_currentPost != -1)			{				deselectTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onDeselectTimerComplete, false, 0, true);				deselectTimer.start();			}					}		/////////////////////////////////////////////////////////////////////////////////////		// onDeselectTimerComplete -----------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////		public function onDeselectTimerComplete(e:TimerEvent):void		{			deselectTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onDeselectTimerComplete);			rollOver.dispatch(nullNavitationInfo);		}		/////////////////////////////////////////////////////////////////		// onVideoOpened ------------------------------------------------		/////////////////////////////////////////////////////////////////		public function onVideoOpened(id:String):void {			removeClips();		}		/////////////////////////////////////////////////////////////////		// onVideoClosed ------------------------------------------------		/////////////////////////////////////////////////////////////////		public function onVideoClosed():void {					}		/////////////////////////////////////////////////////////////////		// onGalleryOpened ------------------------------------------------		/////////////////////////////////////////////////////////////////		public function onGalleryOpened():void {			removeClips();		}		/////////////////////////////////////////////////////////////////		// onGalleryClosed ------------------------------------------------		/////////////////////////////////////////////////////////////////		public function onGalleryClosed():void {					}		/////////////////////////////////////////////////////////////////////////////////////		// open -----------------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						public function open (backgroundInfo:PostBackgroundInfo, allowClips:Boolean = true):void		{    								TweenMax.to(_base.getChildAt(0), 1, {tint:backgroundInfo.colors[1]});						var availableColors:int = backgroundInfo.colors.length-3;			var initColor:int = 2;			var randomColor:int;			TweenMax.killTweensOf(_base.getChildAt(1));			randomColor = initColor + Math.random() * availableColors;			TweenMax.to(_base.getChildAt(1), 1, {tint:backgroundInfo.colors[randomColor], delay:0});			TweenMax.killTweensOf(_base.getChildAt(1));			randomColor = initColor + Math.random() * availableColors;			TweenMax.to(_base.getChildAt(2), 1, {tint:backgroundInfo.colors[randomColor], delay:0.2});			TweenMax.killTweensOf(_base.getChildAt(1));			randomColor = initColor + Math.random() * availableColors;			TweenMax.to(_base.getChildAt(3), 1, {tint:backgroundInfo.colors[randomColor], delay:0.4});			TweenMax.killTweensOf(_base.getChildAt(1));			randomColor = initColor + Math.random() * availableColors;			TweenMax.to(_base.getChildAt(4), 1, {tint:backgroundInfo.colors[randomColor], delay:0.6});						// Clear			if(allowClips){				if(_container.numChildren > 0) colorizeClips(backgroundInfo);					else addClips(backgroundInfo);				}				else{				removeClips();			}					}		/////////////////////////////////////////////////////////////////////////////////////		// colorizeClips -------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						public function colorizeClips(backgroundInfo:PostBackgroundInfo):void		{			var colorPool:ColorPool = new ColorPool();			for each(var color:uint in backgroundInfo.colors)colorPool.addColor(color);						for( var i:int =0; i<_container.numChildren; i++){				var clip:DisplayObject = _container.getChildAt(i);				TweenMax.killTweensOf(clip);				TweenMax.to(clip, 0.4,{tint:colorPool.getColor(), delay:Math.random()*0.6});			}		}		/////////////////////////////////////////////////////////////////////////////////////		// addClips -------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						public function addClips(backgroundInfo:PostBackgroundInfo):void		{			var colorPool:ColorPool = new ColorPool();			for each(var color:uint in backgroundInfo.colors)colorPool.addColor(color);						var gridLayout:GridLayout = new GridLayout(w*0.23 , 0, w*0.6 / _clipsCols, h*0.6/(Math.ceil(_nClips/_clipsCols)), _clipsCols);									pool = new ObjectPool([Shape3,Shape2, Shape1], _nClips);			pool.onRequestObject = function(clip):void {				gridLayout.applyLayout(clip);				colorPool.colorChildren(clip);								clip.alpha = 0.1+Math.random()*0.3;				// object, property, speed, ease, min, max, isRelative								// removing the vibration, to spare cpu				/*				var xVib:FixedVibration = new FixedVibration(	clip,															 	"x",															 	0.9,															 	0.01,																-20,															 	20,															 	true															 );															 					var yVib:FixedVibration = new FixedVibration(	clip,																"y",																0.9,																0.01,																-20,																20,																true															);								*/				// object, property, spring, ease, min, max, radius				var sProx:SimpleProximity = new SimpleProximity(clip,																"scale",																0.1+Math.random()*0.5,																0.1+Math.random()*1,																0,																2.5, 																200																);																				var rProx:SimpleProximity = new SimpleProximity(clip,																"rotation",																0.95,																0.01,																0,																180,																100																);								sProx.start();				rProx.start();							// removing the vibration, to spare cpu				/*				xVib.start();				yVib.start();				*/								clip.scaleX = 0;				clip.scaleY = 0;								_container.addChild(clip);							}						pool.requestAll();		}		/////////////////////////////////////////////////////////////////////////////////////		// removeClips -------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						public function removeClips ():Boolean		{			var nClips:int = _container.numChildren;			var isEmpty:Boolean = (nClips > 0) ? false:true;			if(isEmpty) return false;			for(var i:int = 0; i<nClips; i++) pool.release(_container.getChildAt(i));			for(var j:int = 0; j<nClips; j++) _container.removeChildAt(_container.numChildren-1);			return true;		}		/////////////////////////////////////////////////////////////////////////////////////		// onClipRemovalTweenComplete -------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						public function onClipRemovalTweenComplete (container:Sprite, clip:Sprite):void		{			container.removeChild(clip);			clip = null;		}				/////////////////////////////////////////////////////////////////////////////////////		// resize ---------------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						public function resize (width:int, height:int):void		{			_w = width;			_h = height;			//_base.x = (width-_base.width) / 2;			//_base.y = (height-_base.height) / 2;						//bmc.x = (width-bmc.width) / 2;			//bmc.y = (height-bmc.height) / 2;    		//this.x = (width - this.width) / 2;    		//this.y = (height - this.height) / 2;    		_container.x = (_w-w) / 2;			_container.y = (_h-_clipsH) / 2;    		    		_base.getChildAt(0).width = width;    		_base.getChildAt(0).height = height;    		_base.getChildAt(1).x = 0;    		_base.getChildAt(1).y = 0;			_base.getChildAt(2).x = width - w;			_base.getChildAt(2).y = 0;			_base.getChildAt(3).x = 0;			_base.getChildAt(3).y = height - h;			_base.getChildAt(4).x = width - w;			_base.getChildAt(4).y = height - h;		}		/////////////////////////////////////////////////////////////////////////////////////		// prepareBase --------------------------------------------------------------------		/////////////////////////////////////////////////////////////////////////////////////						private function prepareBase (width:int, height:int):Sprite		{								var sprite:Sprite = new Sprite();						var color:Sprite = new Sprite();    		color.graphics.beginFill(inactiveColor);			color.graphics.drawRect(0,0,width,height);			color.graphics.endFill();			sprite.addChild(color);						var tempGradient:Shape = new Shape();			var fillType:String = GradientType.LINEAR;     		var colors:Array = [inactiveGradientColor,inactiveGradientColor];    		var alphas:Array = [1, 0];     		var ratios:Array = [0x00, 0xFF];     		var matr:Matrix = new Matrix();    		matr.createGradientBox(width*0.5, height);			matr.rotate(45);     		var spreadMethod:String = SpreadMethod.PAD;     		var interpolationMethod:String = InterpolationMethod.LINEAR_RGB;			tempGradient.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod, interpolationMethod);        			tempGradient.graphics.drawRect(0,0,width,height);			tempGradient.graphics.endFill();     		     		var gradientContainer:Sprite = new Sprite();			gradientContainer.addChild(tempGradient);			var mainGradientContainer:Sprite = new Sprite();			mainGradientContainer.addChild(gradientContainer);						// create the blut filter			var filter:BitmapFilter = new BlurFilter(100, 100, BitmapFilterQuality.HIGH);			var myFilters:Array = new Array();			myFilters.push(filter);			mainGradientContainer.filters = myFilters;						// create a "noise" bitmap, so we can merge our gradient with			//var noise:BitmapData = new BitmapData(width, height, true, 0x00000000);			//noise.noise(int(Math.random() * int.MAX_VALUE), 210, 255, 7, true);			var borderWOffset:int = w/10;			var borderHOffset:int = h/10;						gradientContainer.x = 0 - borderWOffset;			gradientContainer.y = 0 - borderHOffset;     		var tl:Bitmap = new Bitmap(new BitmapData(width, height, true, 0x00000000),"auto",true);			tl.bitmapData.draw(mainGradientContainer);  			// merge the  noise bitmadata, but ignoring the alpha			//tl.bitmapData.merge(noise, new Rectangle(0,0,width, height),new Point(0,0),0xff,0xff,0xff,0);     		sprite.addChild(tl);						gradientContainer.scaleX = -1;			gradientContainer.x = w + borderWOffset;			gradientContainer.y = 0 - borderHOffset;			var tr:Bitmap = new Bitmap(new BitmapData(width, height, true, 0x00000000),"auto",true);			tr.bitmapData.draw(mainGradientContainer);     				// merge the  noise bitmadata, but ignoring the alpha			//tr.bitmapData.merge(noise, new Rectangle(0,0,width, height),new Point(0,0),0xff,0xff,0xff,0);			sprite.addChild(tr);						gradientContainer.scaleX = 1;			gradientContainer.scaleY = -1;			gradientContainer.x = 0 - borderWOffset;			gradientContainer.y = h + borderHOffset;			var bl:Bitmap = new Bitmap(new BitmapData(width, height, true, 0x00000000),"auto",true);			bl.bitmapData.draw(mainGradientContainer);			// merge the  noise bitmadata, but ignoring the alpha		//bl.bitmapData.merge(noise, new Rectangle(0,0,width, height),new Point(0,0),0xff,0xff,0xff,0);			sprite.addChild(bl);						gradientContainer.scaleX = -1;			gradientContainer.scaleY = -1;			gradientContainer.x = w + borderWOffset;			gradientContainer.y = h + borderHOffset;			var br:Bitmap = new Bitmap(new BitmapData(width, height, true, 0x00000000),"auto",true);			br.bitmapData.draw(mainGradientContainer);   			// merge the  noise bitmadata, but ignoring the alpha			//br.bitmapData.merge(noise, new Rectangle(0,0,width, height),new Point(0,0),0xff,0xff,0xff,0);			sprite.addChild(br);						TweenMax.to(tl, 1, {tint:inactiveGradientColor});			TweenMax.to(tr, 1, {tint:inactiveGradientColor});			TweenMax.to(br, 1, {tint:inactiveGradientColor});			TweenMax.to(bl, 1, {tint:inactiveGradientColor});     		     		return sprite;		}	}}